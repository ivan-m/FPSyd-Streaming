<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ivan Lazar Miljenovic" />
  <title>I Streamed a Stream</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.css"/>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #303030; color: #cccccc; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #cccccc; background-color: #303030; }
code > span.kw { color: #f0dfaf; } /* Keyword */
code > span.dt { color: #dfdfbf; } /* DataType */
code > span.dv { color: #dcdccc; } /* DecVal */
code > span.bn { color: #dca3a3; } /* BaseN */
code > span.fl { color: #c0bed1; } /* Float */
code > span.ch { color: #dca3a3; } /* Char */
code > span.st { color: #cc9393; } /* String */
code > span.co { color: #7f9f7f; } /* Comment */
code > span.ot { color: #efef8f; } /* Other */
code > span.al { color: #ffcfaf; } /* Alert */
code > span.fu { color: #efef8f; } /* Function */
code > span.er { color: #c3bf9f; } /* Error */
code > span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
code > span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code > span.sc { color: #dca3a3; } /* SpecialChar */
code > span.vs { color: #cc9393; } /* VerbatimString */
code > span.ss { color: #cc9393; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #f0dfaf; } /* ControlFlow */
code > span.op { color: #f0efd0; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code > span.at { } /* Attribute */
code > span.do { color: #7f9f7f; } /* Documentation */
code > span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code > span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code > span.in { color: #7f9f7f; font-weight: bold; } /* Information */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <!-- If the query includes 'print-pdf', include the PDF print sheet -->
  <script>
    if( window.location.search.match( /print-pdf/gi ) ) {
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = 'reveal.js/css/print/pdf.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">I Streamed a Stream</h1>
    <h2 class="author">Ivan Lazar Miljenovic</h2>
    <h3 class="date">25 October, 2017</h3>
</section>

<section><section id="streaming" class="titleslide slide level1"><h1><code>Streaming</code></h1></section><section id="about-the-library" class="slide level2">
<h2>About the library</h2>
<aside class="notes">
<ul>
<li>It’s a streaming library called streaming</li>
</ul>
</aside>
<dl>
</dl>
<ul>
<li class="fragment">Unfortunately named</li>
<li class="fragment">Performs well compared to the competition</li>
<li class="fragment">Whilst being a lot simpler!</li>
</ul>
</section><section id="how-i-discovered-streaming" class="slide level2">
<h2>How I discovered <code>streaming</code></h2>
<aside class="notes">
<ul>
<li>Never used any stream processing library before; lazy I/O sufficed!</li>
<li>Had used postgresql-simple with quiver, and could have adapted the code to any stream processing library, but thought to use a standard one.</li>
</ul>
</aside>
<dl>
</dl>
<ul>
<li class="fragment">Introduced to quiver by Patryk Zadarnowski</li>
<li class="fragment">Adopted a package pipes
<ul>
<li class="fragment">Converted to quiver as I needed return values</li>
</ul></li>
<li class="fragment">New project: let’s pick a library that’s actually used by others.
<ul>
<li class="fragment">Needed PostgreSQL support</li>
</ul></li>
<li class="fragment">Conduit: all solutions used <code>persistent</code></li>
<li class="fragment"><code>pipes-postgresql-simple</code> by Oliver Charles
<ul>
<li class="fragment">Wait, it’s deprecated?</li>
<li class="fragment">What’s this “streaming” library?</li>
</ul></li>
</ul>
</section><section id="stream-processing" class="slide level2">
<h2>Stream Processing</h2>
<aside class="notes">
<ul>
<li>Avoiding calling it “streaming”</li>
<li>Nowadays, “stream processing” generally refers to parallel programming.</li>
<li>Usage predates that.</li>
<li>Everyone knows what it is in Haskell, but no real definition.</li>
<li>Not just Haskell: Scala, F#</li>
</ul>
</aside>
<dl>
</dl>
<div class="fragment">
<blockquote>
<p>[…] P J Landin’s original use for streams was to model the histories of loop variables, but he also observed that streams could have been used as a model for I/O in ALGOL 60.</p>
<p>– <em>A Survey Of Stream Processing, R. Stephens, 1995</em></p>
</blockquote>
</div>
</section><section class="slide level2">

<blockquote>
<p><em>Stream processing</em> defines a pipeline of operators that transform, combine, or reduce (even to a single scalar) large amounts of data. Characteristically, data is accessed strictly linearly rather than randomly and repeatedly – and processed uniformly. The upside of the limited expressiveness is the opportunity to process large amount of data efficiently, in constant and small space.</p>
<p>– <em>Oleg Kiselyov</em>, <a href="http://okmij.org/ftp/Streams.html" class="uri">http://okmij.org/ftp/Streams.html</a></p>
</blockquote>
</section></section>
<section><section id="a-brief-incomplete-and-mostly-wrong-history-of-stream-processing" class="titleslide slide level1" style="font-size:75%;width:100%"><h1>A Brief, Incomplete, and Mostly Wrong History of Stream Processing</h1></section><section class="slide level2">

<aside class="notes">
<ul>
<li>This is for Haskell</li>
<li>No claims made as to accuracy or completeness</li>
</ul>
</aside>
<dl>
</dl>
<p>… with apologies to James Iry</p>
</section><section id="pre-history-aka-pre-2000" class="slide level2">
<h2>Pre-History (aka pre-2000)</h2>
<aside class="notes">
<ul>
<li>Apparently quote was said at Haskell Symposium in 2008, so people took that motto from the future to heart.</li>
</ul>
</aside>
<dl>
</dl>
<ul>
<li class="fragment">Lazy I/O</li>
<li class="fragment">People grumbled, but accepted it.</li>
<li class="fragment">After all: “avoid success at all costs”.</li>
<li class="fragment"><code class="sourceCode bash"><span class="ex">english</span> -XAllowAmbiguousGrammar</code></li>
</ul>
</section><section id="iteratees" class="slide level2">
<h2>Iteratees</h2>
<ul>
<li class="fragment">By Oleg Kiselyov</li>
<li class="fragment">Dates back to ~2008</li>
<li class="fragment">Everyone praised it for its amazing promise…</li>
<li class="fragment">… but being by Oleg, hardly anyone understood how it worked</li>
</ul>
</section><section id="iteratee" class="slide level2">
<h2><code>iteratee</code></h2>
<ul>
<li class="fragment">Implementation of Iteratees by John Lato</li>
<li class="fragment">2009 – 2014 (with Hackage update in 2016)</li>
</ul>
</section><section id="enumerator" class="slide level2">
<h2><code>enumerator</code></h2>
<aside class="notes">
<ul>
<li>Not sure when/why people started adopting this instead of <code>iteratee</code></li>
<li>e.g. <code>snap</code> quickly switched to this</li>
</ul>
</aside>
<dl>
</dl>
<ul>
<li class="fragment">Alternative implementation of Iteratees by John Millikin</li>
<li class="fragment">2010 – 2011</li>
<li class="fragment">Often referred to as an “iteratee” still</li>
</ul>
</section><section id="conduit" class="slide level2">
<h2><code>conduit</code></h2>
<aside class="notes">
<ul>
<li>Absorbed ideas from each other</li>
<li>Conduit now has an implementation of pipes under the hood</li>
<li>Conduit still claims to be more “production grade”</li>
</ul>
</aside>
<dl>
</dl>
<ul>
<li class="fragment">By Michael Snowman</li>
<li class="fragment">First released 2011, still active</li>
<li class="fragment">Declared as a more industrial/production-grade solution than pipes
<ul>
<li class="fragment">Without defining either term</li>
<li class="fragment">Even though pipes didn’t yet exist</li>
</ul></li>
</ul>
</section><section id="pipes" class="slide level2">
<h2><code>pipes</code></h2>
<ul>
<li class="fragment">By Gabriel Gonzalez</li>
<li class="fragment">First released in 2012, still active</li>
<li class="fragment">Tried to validate anti-Haskeller’s opinions of “too much maths” by basing it on Category Theory.</li>
</ul>
</section><section id="the-great-conduit-pipes-war" class="slide level2">
<h2>The great conduit-pipes war</h2>
<ul>
<li class="fragment">Fought primarily on the battlefields of Twitter and Reddit</li>
<li class="fragment">Devolved into “best frenemies” situation</li>
<li class="fragment"><blockquote>
<p>Enemies, as well as lovers, come to resemble each other over a period of time.</p>
<p>– <em>Sydney J. Harris</em></p>
</blockquote></li>
</ul>
</section><section id="machines" class="slide level2">
<h2><code>machines</code></h2>
<aside class="notes">
<ul>
<li>Translates to “this is not a pipe”</li>
</ul>
</aside>
<dl>
</dl>
<ul>
<li class="fragment">By Edward Kmett
<ul>
<li class="fragment">As such, lots of great ideas with minimal documentation</li>
</ul></li>
<li class="fragment">First released in 2012, still active</li>
<li class="fragment">“Networked stream transducers”</li>
<li class="fragment">Allows for multiple inputs</li>
<li class="fragment"><em>Ceci n’est pas une pipe</em></li>
</ul>
</section><section id="io-streams" class="slide level2">
<h2><code>io-streams</code></h2>
<aside class="notes">
<ul>
<li>Less used than conduits and pipes</li>
</ul>
</aside>
<dl>
</dl>
<ul>
<li class="fragment">By Gregory Collins</li>
<li class="fragment">First released in 2013, still active</li>
<li class="fragment">Aims to be simpler (e.g. no monad transformers) than the others</li>
<li class="fragment">Developed for use with Snap Framework</li>
</ul>
</section><section id="quiver" class="slide level2">
<h2><code>quiver</code></h2>
<aside class="notes">
<ul>
<li>I probably wrote the most quiver code out of anyone</li>
<li>The complexity in question is to allow both pushing and pulling of values, but in practice we just pushed.</li>
</ul>
</aside>
<dl>
</dl>
<ul>
<li class="fragment">By Patryk Zadarnowski</li>
<li class="fragment">All releases in 2015</li>
<li class="fragment">What you get when you say “You know what pipes needs? More complexity!”</li>
<li class="fragment">Return values actually useful!</li>
</ul>
</section><section id="streaming-1" class="slide level2">
<h2><code>streaming</code></h2>
<aside class="notes">
<ul>
<li>The subject of this talk</li>
<li>See, I got here eventually!</li>
</ul>
</aside>
<dl>
</dl>
<ul>
<li class="fragment">By Michael Thompson
<ul>
<li class="fragment">Now maintained by Andrew Martin and a GitHub organization</li>
</ul></li>
<li class="fragment">First released in 2015</li>
<li class="fragment">“The freely generated stream on a streamable functor”</li>
</ul>
</section><section class="slide level2">

<aside class="notes">
<ul>
<li>Original announcement</li>
<li>Wait, that isn’t right…</li>
</ul>
</aside>
<dl>
</dl>
<blockquote>
<p>I’m doing a (free) stream processing library (just a hobby, won’t be big and professional like gnu) for Haskell. This has been brewing since august, and is starting to get ready. I’d like any feedback on things people like/dislike in pipes, as my library is an attempt to implement <code>FreeT</code> in the style of <code>Pipes.Internal</code>.</p>
</blockquote>
</section><section class="slide level2">

<aside class="notes">
<ul>
<li>OK, real announcement on haskell-pipes mailing list</li>
</ul>
</aside>
<dl>
</dl>
<blockquote>
<p>It’s probably a terrible idea!</p>
<p><code>streaming</code> is an attempt to implement <code>FreeT</code> in the style of <code>Pipes.Internal</code>, with a zillion more associated functions. There is a Prelude especially for the fundamental ‘Producer’ case - <code>Stream ((,) a) m r</code> and its iterations, <code>Stream (Stream ((,)a) m) m r</code>.</p>
</blockquote>
</section></section>
<section><section id="compare-the-types" class="titleslide slide level1"><h1>Compare the types</h1></section><section id="pipes-1" class="slide level2">
<h2><code>pipes</code></h2>
<aside class="notes">
<ul>
<li>This first as it makes it easier to compare conduit to pipes</li>
<li>Can feed values in both directions</li>
</ul>
</aside>
<dl>
</dl>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Proxy</span> a&#39; a b&#39; b m r
    <span class="fu">=</span> <span class="dt">Request</span> a&#39; (a  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> a&#39; a b&#39; b m r )
    <span class="fu">|</span> <span class="dt">Respond</span> b  (b&#39; <span class="ot">-&gt;</span> <span class="dt">Proxy</span> a&#39; a b&#39; b m r )
    <span class="fu">|</span> <span class="dt">M</span>          (m    (<span class="dt">Proxy</span> a&#39; a b&#39; b m r))
    <span class="fu">|</span> <span class="dt">Pure</span>    r</code></pre></div>
</section><section id="conduit-1" class="slide level2">
<h2><code>conduit</code></h2>
<aside class="notes">
<ul>
<li><code>Pipe ⩰ Proxy + Leftovers</code></li>
</ul>
</aside>
<dl>
</dl>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ConduitM</span> i o m r <span class="fu">=</span> <span class="dt">ConduitM</span>
    {<span class="ot"> unConduitM ::</span> forall b<span class="fu">.</span>
                    (r <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i i o () m b) <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i i o () m b
    }

<span class="kw">data</span> <span class="dt">Pipe</span> l i o u m r <span class="fu">=</span>
    <span class="dt">HaveOutput</span> (<span class="dt">Pipe</span> l i o u m r) (m ()) o
  <span class="fu">|</span> <span class="dt">NeedInput</span> (i <span class="ot">-&gt;</span> <span class="dt">Pipe</span> l i o u m r) (u <span class="ot">-&gt;</span> <span class="dt">Pipe</span> l i o u m r)
  <span class="fu">|</span> <span class="dt">Done</span> r
  <span class="fu">|</span> <span class="dt">PipeM</span> (m (<span class="dt">Pipe</span> l i o u m r))
  <span class="fu">|</span> <span class="dt">Leftover</span> (<span class="dt">Pipe</span> l i o u m r) l</code></pre></div>
</section><section id="streaming-2" class="slide level2">
<h2><code>streaming</code></h2>
<aside class="notes">
<ul>
<li>No input values!</li>
<li><code>Functor f</code></li>
<li>Where are the actual output values?</li>
</ul>
</aside>
<dl>
</dl>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Stream</span> f m r <span class="fu">=</span> <span class="dt">Step</span> <span class="fu">!</span>(f (<span class="dt">Stream</span> f m r))
                  <span class="fu">|</span> <span class="dt">Effect</span> (m (<span class="dt">Stream</span> f m r))
                  <span class="fu">|</span> <span class="dt">Return</span> r</code></pre></div>
<div class="fragment">
<p>Wait, that can’t be it, can it?</p>
</div>
</section><section id="outputting-values" class="slide level2">
<h2>Outputting values</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | A left-strict pair; the base functor for streams of individual elements.</span>
<span class="kw">data</span> <span class="dt">Of</span> a b <span class="fu">=</span> <span class="fu">!</span>a <span class="fu">:&gt;</span> b

<span class="dt">Stream</span> (<span class="dt">Of</span> a) m r ≆ m ([a], r)</code></pre></div>
<ul>
<li class="fragment">Why <code>f</code> rather than <code>Step !a (Stream f m r)</code>?
<ul>
<li class="fragment">Patience!</li>
</ul></li>
</ul>
</section><section id="what-this-means" class="slide level2">
<h2>What this means</h2>
<aside class="notes">
<ul>
<li>Conduit is considering ditching foralls</li>
</ul>
</aside>
<dl>
</dl>
<ul>
<li class="fragment"><code>Stream (Of a) m r</code> is analogous to a <code>Source</code> or <code>Producer</code> in conduit and pipes</li>
<li class="fragment">No need for <code>forall</code> vs <code>()</code> vs <code>Void</code> confusion!</li>
<li class="fragment">All other stream processors represent how to transform input to output.
<ul>
<li class="fragment">Streaming instead uses normal functions and function composition!</li>
</ul></li>
<li class="fragment">Conduit uses a similar type for its internal Stream Fusion framework!</li>
</ul>
</section></section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,         // Display controls in the bottom right corner
        progress: true,         // Display a presentation progress bar
        history: true,          // Push each slide change to the browser history
        zoomKey: 'shift',
        center: true,                       // Vertical centering of slides
        maxScale: 1.5,                  // Bounds for smallest/largest possible content scale
        slideNumber: false,                // Display the page number of the current slide
        theme: 'night', // available themes are in /css/theme
        transition: 'concave', // default/cube/page/concave/zoom/linear/fade/none
        backgroundTransition: 'zoom', // default/none/fade/slide/convex/concave/zoom

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
